package confx

import (
	"errors"
	"io/ioutil"
	"log"
	"os"
	"os/user"
	"path/filepath"
	"strings"
	"sync"

	"github.com/kardianos/osext"

	"github.com/senpan/xtools/flagx"
)

// Config interface definition
// developers can implement this interface to combine with other config library
type Config interface {
	// MustValue get value by section and key,if not exist,return the defaultVal
	MustValue(section, key string, defaultVal ...string) string
	// MustValueArray get value by section and key and split value by delimiter,return array
	MustValueArray(section, key, delimiter string) []string
	// GetKeyList get section value,return array
	GetKeyList(section string) []string
	// GetSection get section value,return map
	GetSection(section string) (map[string]string, error)
	// GetSectionList get all section list
	GetSectionList() []string
	// GetSectionToObject get object value by section
	GetSectionToObject(section string, obj interface{}) error
}

var (
	// global cache
	// only load the config file once
	// after config init complete,all config data get from cache
	configCache = struct {
		sync.RWMutex
		cache map[string]Config
	}{cache: make(map[string]Config, 0)}
	// global config
	gCfg Config
	// options config
	opt options
)

// InitConfig config init function
// include 3 load module(ini,yaml,any),any is a plugin module,support second develop
func InitConfig(opts ...Option) {
	// check if config has initialized
	if gCfg != nil {
		return
	}
	// options func
	for _, fn := range opts {
		fn(&opt)
	}
	// get the path prefix args
	// when the path is an opposite path, you need set the prefix,default user home,like "/home/dev"
	confPathPrefix := flagx.GetConfigPathPrefix()
	if len(*confPathPrefix) != 0 {
		opt.pathPrefix = *confPathPrefix
	}

	var err error
	path := getConfigFile()
	log.Printf("[xtools.configx] init,path:%s", path)
	// load config from path
	if gCfg, err = loadFile(path); err != nil {
		gCfg = nil
		log.Printf("[xtools.confx] loadFile config file,err:%+v", err)
	}
}

func getConfigFile() string {
	path := opt.config
	// get the path args
	config := flagx.GetConfig()
	// set the default config path
	if len(*config) != 0 {
		return *config
	}
	if path == "" {
		path = "../conf/conf.yaml"
	}
	return path
}

// the default base directory if file path not exist or invalid,default "/home/www"
func home() string {
	if usr, err := user.Current(); err == nil {
		return usr.HomeDir
	}
	return "/home/www"
}

// default testdata directory,generated by home()
func defaultHome() string {
	if len(opt.pathPrefix) > 0 {
		return opt.pathPrefix
	}
	if path, err := osext.ExecutableFolder(); err == nil {
		if strings.HasPrefix(path, "/tmp/go-build") {
			return home() + "/conf"
		}
		return path
	} else {
		return "."
	}
}

// loadFile file load function
// include 2 load module(ini,yaml)
func loadFile(path string) (cfg Config, err error) {
	// load ini or yaml
	// path must have more than 3 bytes
	if len([]byte(path)) < 4 {
		return nil, errors.New("path invalid")
	}

	// default load module
	fileType := "ini"

	if path[len(path)-4:] == "yaml" {
		fileType = "yaml"
	} else if path[len(path)-4:] != ".ini" {
		// if the path suffix is not ".ini", completed path by append ".ini"
		path = path + ".ini"
	}
	// config cache
	var ok bool
	configCache.RLock()
	// read cache first
	cfg, ok = configCache.cache[path]
	configCache.RUnlock()
	// no cache
	if !ok {
		// path invalid,path completed
		if !strings.HasPrefix(path, "/") {
			path = defaultHome() + "/" + path
			if _, err := os.Stat(path); os.IsNotExist(err) {
				path = home() + "/conf/" + filepath.Base(path)
			}
		}
		content, ie := ioutil.ReadFile(path)
		if ie != nil {
			err = ie
			log.Printf("loadIniFile error: %v", ie)
			return nil, err
		}
		if opt.env {
			// customizes the config to use environment variables.
			content = []byte(os.ExpandEnv(string(content)))
		}
		// load file and create cache
		configCache.Lock()
		if fileType == "yaml" {
			if cfg, err = loadYamlFile(content); err == nil {
				configCache.cache[path] = cfg
			}
		} else {
			if cfg, err = loadIniFile(content); err == nil {
				configCache.cache[path] = cfg
			}
		}
		configCache.Unlock()
	}
	return
}

// Reset cache force clear
// NOTICE:clear the cache only you change the config source
func Reset() {
	configCache.Lock()
	configCache.cache = make(map[string]Config, 0)
	gCfg = nil
	opt = options{}
	configCache.Unlock()
}

// GetConf get config function
func GetConf(sec, key string) string {
	if gCfg == nil {
		log.Printf("[xtools.confx] cfg init failed,sec:%s,key:%s,at:%v", sec, key, flagx.GetConfig())
		return ""
	}
	// if value not existed return ""
	return gCfg.MustValue(sec, key, "")
}

// GetConfByDefault get config with default
// if value not existed,return default value def
func GetConfByDefault(sec, key, def string) string {
	if gCfg == nil {
		log.Printf("[xtools.confx] cfg init failed,sec:%s,key:%s,at:%v", sec, key, flagx.GetConfig())
		return ""
	}
	// if value not existed return def
	return gCfg.MustValue(sec, key, def)
}

// GetConfToSlice get configs function
func GetConfToSlice(sec, key string) []string {
	if gCfg == nil {
		log.Printf("[xtools.confx] cfg init failed,sec:%s,key:%s", sec, key)
		return []string{}
	}
	// if value not existed return " "
	return gCfg.MustValueArray(sec, key, " ")
}

// GetConfToMap get configmap
// return map[string]string
func GetConfToMap(sec string) (ret map[string]string) {
	if gCfg == nil {
		log.Printf("[xtools.confx] cfg init failed,sec:%s", sec)
		return nil
	}
	var err error
	// if value not existed return empty map
	if ret, err = gCfg.GetSection(sec); err != nil {
		log.Printf("[xtools.confx] GetSection err:%+v", err)
		ret = make(map[string]string, 0)
	}
	return
}

// GetConfToArrayMap get config map
// return map[string][]string
func GetConfToArrayMap(sec string) (ret map[string][]string) {
	if gCfg == nil {
		log.Printf("[xtools.confx] cfg init failed,sec:%s", sec)
		return nil
	}
	ret = make(map[string][]string, 0)
	// get all keys
	keyList := gCfg.GetKeyList(sec)
	// get all config by range keys
	for _, k := range keyList {
		ret[k] = gCfg.MustValueArray(sec, k, " ")
	}
	return
}

// ParseConfToStruct get config value with object value return
func ParseConfToStruct(sec string, v interface{}) error {
	if gCfg == nil {
		log.Printf("[xtools.confx] cfg init failed,sec:%s", sec)
		return nil
	}
	return gCfg.GetSectionToObject(sec, v)
}
