package confx

import (
	"errors"
	"log"
	"os"
	"os/user"
	"path/filepath"
	"strings"
	"sync"

	"github.com/kardianos/osext"

	"github.com/senpan/xtools/flagx"
)

// Config interface definition
// developers can implement this interface to combine with other config library
type Config interface {
	// MustValue get value by section and key,if not exist,return the defaultVal
	MustValue(section, key string, defaultVal ...string) string
	// MustValueArray get value by section and key and split value by delimiter,return array
	MustValueArray(section, key, delimiter string) []string
	// GetKeyList get section value,return array
	GetKeyList(section string) []string
	// GetSection get section value,return map
	GetSection(section string) (map[string]string, error)
	// GetSectionList get all section list
	GetSectionList() []string
	// GetSectionToObject get object value by section
	GetSectionToObject(section string, obj interface{}) error
}

var (
	// global cache
	// only load the config file once
	// after config init complete,all config data get from cache
	configCache = struct {
		sync.RWMutex
		cache map[string]Config
	}{cache: make(map[string]Config, 0)}
	// when you don't want to use ini or yaml file source,you need the "any" pattern
	// the "any" pattern can customize the data source by register a plugin
	anyFileMap = make(map[string]func() (Config, error), 0)
	// global config
	gCfg Config
	// config path prefix if your config path is not an absolute path
	userConfPath string
)

// InitConfig config init function
// include 3 load module(ini,yaml,any),any is a plugin module,support second develop
func InitConfig() {
	// check if config has initialized
	if gCfg != nil {
		return
	}

	// get the path prefix args
	// when the path is an opposite path, you need set the prefix,default user home,like "/home/dev"
	confPathPrefix := flagx.GetConfigPathPrefix()
	if len(*confPathPrefix) != 0 {
		SetConfPathPrefix(*confPathPrefix)
	}

	// get the path args
	config := flagx.GetConfig()
	var err error

	// set the default config path
	if len(*config) == 0 {
		*config = "../conf/conf.yaml"
	}
	log.Printf("[xtools.configx] init,path:%s", *config)
	// load config from path
	if gCfg, err = Load(*config); err != nil {
		gCfg = nil
		log.Printf("[xtools.confx] Load config file,err:%+v", err)
	}
}

// the default base directory if file path not exist or invalid,default "/home/dev"
func home() string {
	if usr, err := user.Current(); err == nil {
		return usr.HomeDir
	}
	return "/home/www"
}

// default testdata directory,generated by home()
func defaultHome() string {
	if len(userConfPath) > 0 {
		return userConfPath
	}
	if path, err := osext.ExecutableFolder(); err == nil {
		if strings.HasPrefix(path, "/tmp/go-build") {
			return home() + "/conf"
		}
		return path
	} else {
		return "."
	}
}

// SetConfPathPrefix path prefix,if the path is not absolute path,you can
// set the prefix manual
func SetConfPathPrefix(fullPathPrefix string) {
	if len(fullPathPrefix) != 0 {
		userConfPath = fullPathPrefix
	}
}

func SetConfPathPrefixByPwd() {
	pwd, _ := os.Getwd()
	userConfPath = pwd
}

// Load file load function
// include 3 load module(ini,yaml,any),any module support plugins
// by use flag -c=xxx,and you need provide a xxx.go which implement the
// Config interface and register the load function in plugin.go
func Load(path string) (cfg Config, err error) {
	// load any module
	// path is not a valid path
	if !strings.Contains(path, "/") {
		fn, ok := anyFileMap[path]
		if ok {
			cfg, err = fn()
			return
		}
	}

	// load ini or yaml
	// path must have more than 3 bytes
	if len([]byte(path)) < 4 {
		return nil, errors.New("path invalid")
	}

	// default load module
	fileType := "ini"

	if path[len(path)-4:] == "yaml" {
		fileType = "yaml"
	} else if path[len(path)-4:] != ".ini" {
		// if the path suffix is not ".ini", completed path by append ".ini"
		path = path + ".ini"
	}
	// config cache
	var ok bool
	configCache.RLock()
	// read cache first
	cfg, ok = configCache.cache[path]
	configCache.RUnlock()
	// no cache
	if !ok {
		// path invalid,path completed
		if !strings.HasPrefix(path, "/") {
			path = defaultHome() + "/" + path
			if _, err := os.Stat(path); os.IsNotExist(err) {
				path = home() + "/conf/" + filepath.Base(path)
			}
		}
		// load file and create cache
		configCache.Lock()
		if fileType == "yaml" {
			if cfg, err = loadYamlFile(path); err == nil {
				configCache.cache[path] = cfg
			}
		} else {
			if cfg, err = loadIniFile(path); err == nil {
				configCache.cache[path] = cfg
			}
		}
		configCache.Unlock()
	}
	return
}

// Reset cache force clear
// NOTICE:clear the cache only you change the config source
func Reset() {
	configCache.Lock()
	configCache.cache = make(map[string]Config, 0)
	gCfg = nil
	configCache.Unlock()
}

// GetConf get config function
func GetConf(sec, key string) string {
	InitConfig()
	if gCfg == nil {
		log.Printf("[xtools.confx] cfg init failed,sec:%s,key:%s,at:%v", sec, key, flagx.GetConfig())
		return ""
	}
	// if value not existed return ""
	return gCfg.MustValue(sec, key, "")
}

// GetConfByDefault get config with default
// if value not existed,return default value def
func GetConfByDefault(sec, key, def string) string {
	InitConfig()
	if gCfg == nil {
		log.Printf("[xtools.confx] cfg init failed,sec:%s,key:%s,at:%v", sec, key, flagx.GetConfig())
		return ""
	}
	// if value not existed return def
	return gCfg.MustValue(sec, key, def)
}

// GetConfToSlice get configs function
func GetConfToSlice(sec, key string) []string {
	InitConfig()
	if gCfg == nil {
		log.Printf("[xtools.confx] cfg init failed,sec:%s,key:%s", sec, key)
		return []string{}
	}
	// if value not existed return " "
	return gCfg.MustValueArray(sec, key, " ")
}

// GetConfToMap get configmap
// return map[string]string
func GetConfToMap(sec string) (ret map[string]string) {
	InitConfig()
	if gCfg == nil {
		log.Printf("[xtools.confx] cfg init failed,sec:%s", sec)
		return nil
	}
	var err error
	// if value not existed return empty map
	if ret, err = gCfg.GetSection(sec); err != nil {
		log.Printf("[xtools.confx] GetSection err:%+v", err)
		ret = make(map[string]string, 0)
	}
	return
}

// GetConfToArrayMap get config map
// return map[string][]string
func GetConfToArrayMap(sec string) (ret map[string][]string) {
	InitConfig()
	if gCfg == nil {
		log.Printf("[xtools.confx] cfg init failed,sec:%s", sec)
		return nil
	}
	ret = make(map[string][]string, 0)
	// get all keys
	keyList := gCfg.GetKeyList(sec)
	// get all config by range keys
	for _, k := range keyList {
		ret[k] = gCfg.MustValueArray(sec, k, " ")
	}
	return
}

// ParseConfToStruct get config value with object value return
func ParseConfToStruct(sec string, v interface{}) error {
	InitConfig()
	if gCfg == nil {
		log.Printf("[xtools.confx] cfg init failed,sec:%s", sec)
		return nil
	}
	return gCfg.GetSectionToObject(sec, v)
}
